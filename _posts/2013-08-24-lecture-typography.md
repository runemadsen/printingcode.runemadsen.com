---
layout:     default
title:      Typography
date:       2013-08-24 19:15:22
categories: printing-code
---

Typography
==========

I'm not sure that anything successful can come out of generative typography, but hey, let's do a class on it. The presentation is mostly a collection of things I think are interesting, and not so much a world-view of computational typography.

<iframe src="http://player.vimeo.com/video/20759580?title=0&amp;byline=0&amp;portrait=0" width="600" height="338" frameborder="0" > </iframe>

Obviously, when we see footage like this, we realize that fonts - almost above anything else - have the widest range of expression. They are at the same time purely functional and purely aesthetic.  

Today we'll look at ways to make type systems: fonts created by using some kind of rule, instead of a manual plotting of the polygon outlines. This can be many things.

<iframe width="600" height="338" src="http://www.youtube.com/embed/up1d_fagy6Q" frameborder="0" > </iframe>


Short Introduction to Typography
---------------------------------

The history of typefaces is in many ways tied to the technological developements of printmaking.

Of course typography is a field that originated in handwriting. Here it's a so-called illuminated manuscript from the middle ages.

{% picture illuminated-692c7500f67e8dcdb6e9b001db33dfa9.jpg %}

Then along came Gutenberg with the printing press. As you can see, the typefaces were still very bound to the art of handwriting.

{% picture gutenberg-d8dfdcf4b9731963b9cbd74f80445fd0.jpg %}

This slowly changed, as font designers started using the grid as a design tool.

{% picture fontgrid-f093b6c4c7d01d8036b14a95cfcb5eb7.jpg %}

{% picture fontgrid2-9a3e9c99b4a3f7b8c08f954f1543387b.jpg %}

The linotype machine

{% picture linotype-0341b0c8e878e4e55163d9b94457129f.jpg %}

The computer

{% picture star-911164097c524160d714c42da58970ad.jpg %}

Here's the dadaist poster I showed you in the first class, that was a direct comment on the strict, horizontal grid from the movable type machines.

{% picture dada_show-c9d0fafbb5a45d14cd8c16d659387d45.jpg %}

Many of the things we now consider essential to modern typefaces has deep roots within these traditions. A good is example is the idea of "uppercase" and "lowercase" letter, that was actually a description of where the letters where stored in a printmakers desk.

{% picture upperlowercase-e59784e8c78950b69f206e14a7220e45.jpg %}

The most important thing for you to start notice, is the difference between different typefaces. Treat them like you treated your forms in these first assignments. Think about where you would use them. Even Helvetica has a specific expression and needs to be chosen wisely.

{% picture typefaces-2f52384de253a0978056318497acfcef.jpg %}


Type Classification
-------------------

The following walk-through has been borrowed from "[a crash course in typography](http://www.noupe.com/design/a-crash-course-in-typography-the-basics-of-type.html)".

The broadest way to classify fonts is by their broad type category. Here's a few of these.

### Serif

Serif typefaces are called "serifs" because they have smaller lines (called serifs) connected to the main strokes of characters. Serifs are visual signatures from the time of handwriting, that originally were visual clues to distinguish written letters from each other. The concept transferred to print when printing small type. Here's a quick overview on the evolution of serifs.

{% picture 1-serif-0e3b1868cbeed16b8cb8e307bc106f68.jpg %}

**Old Style Serifs** is a sub-category of serif typefaces. The main characteristic of old style characters is their diagonal stress (the thinnest parts of the letters appear on the angled strokes, rather than the vertical or horizontal ones). 

{% picture 1-oldstyleserif-c0cf423ab4be1a631f5135c2a91e6c72.jpg %}

**Transitional serifs** date back to the mid 1700s, and are generally the most common serif typefaces. Times New Roman and Baskerville are both transitional serifs, as are Caslon, Georgia, and Bookman. The differences between thick and thin strokes in transitional typefaces are more pronounced than they are in old style serifs, but less so than in modern serifs.

{% picture 1-transitionalserif-6e5fd23cc7a3310971eb6f52e00990b6.jpg %}

**Modern serifs**, which include typefaces like Didot and Bodoni, have a much more pronounced contrast between thin and thick lines, and have have a vertical stress and minimal brackets. They date back to the late 1700s.

{% picture 1-modernserif-a6ec8286a06ae9958ddd141b65f9c452.jpg %}

**Slab serifs** have little to no contrast between thick and thin lines, and have thick, rectangular serifs, and sometimes have fixed widths. The underlying characters hapes often more closely resemble sans serif fonts.

{% picture 1-slabserif-d1d7c084fe7d31ec0342b47e7e4c6676.jpg %}


### Sans-serif

Sans-serif typefaces are just that: typefaces without serifs. We know them from the first and second modernist waves to hit the US in the 60's and 70's, with artists like Josef Müller-Brockmann and Alvin Lustig. The first sans-serifs were created in the late 18th century.

{% picture 1-sansserif-6c08d9fcff14542d31b9f810dfe6e491.jpg %}

There are four basic classifications of sans-serif typefaces: Grotesque, Neo-grotesque, Humanist, and Geometric. 

**Grotesques** are the earliest, and include fonts like Franklin Gothic and Akzidenze Grotesk. These typefaces often have letterforms that are very similar to serif typefaces, minus the serifs.

{% picture 1-grotesquesansserif-5b75132c3f9129171837de8efda86ae7.jpg %}

**Neo-grotesque** typefaces include some of the most common typefaces: Arial, Helvetica and Univers are all neo-grotesques. They have a relatively plain appearance when compared to the grotesques.

{% picture 1-neogrotesquesansserif-f74f13ece6254943fc42a6f8cb4d17c3.jpg %}

**Humanist typefaces** include Gill Sans, Frutiger, Tahoma, Verdana, Optima, and Lucide Grande. These are more calligraphic than other sans-serif typefaces, and are also the most legible (hence the popularity of some of them for website body copy). They’re more calligraphic than other sans-serifs, meaning they have a greater variation in line widths.

{% picture 1-humanistsansserif-54b230bad617edcdb378191f649e6c35.jpg %}

**Geometric sans-serifs** are more closely based on geometric shapes. Generally, the “O”s in geometrics will appear circular, and the letter “a” is almost always simple, just a circle with a tail. They’re the least commonly-used for body copy, and are also the most modern sans-serifs, as a general rule.

{% picture 1-geometricsansserif-0c1fe7097512f29761cf4766ecd4ce6a.jpg %}

### Script

Scripts are based upon handwriting, and offer very fluid letterforms. There are two basic classifications: formal and casual. 

**Formal scripts** are often reminiscent of the handwritten letterforms common in the 17th and 18th centuries. 

{% picture 1-formalscript-6323f7c63e56fe6df717648268b1d64e.jpg %}

**Casual scripts** more closely resemble modern handwriting, and date back to the mid-twentieth century. They’re much less formal, often with stronger strokes and a more brush-like appearance. Casual scripts include Mistral and Brush Script.

{% picture 1-casualscript-7157b1df1676c809a543caa834926c87.jpg %}


### Display

Display typefaces are probably the broadest category and include the most variation. The main characteristic is that they’re unsuitable for body copy and are best reserved for headlines or other short copy that needs attention drawn to it. Display typefaces can be formal, or informal, and evoke any kind of mood. They’re more commonly seen in print design, but are becoming more popular online with the use of web fonts.

{% picture 1-display-e390f8000bcf7e6128ee20e734995070.jpg %}


### Dingbats and Speciality Typefaces

Dingbats are specialty typefaces that consist of symbols and ornaments instead of letters. Wingdings is probably the best-known dingbat font, though there are now thousands, often created around themes.

{% picture 1-dingbats-03bb2ff2e3cfd5f6381631900f680944.jpg %}


### Proportional vs. Monospaced

Another way to categorize typefaces is by their spacing. 

**Proportional typefaces** uses varied spacing depending on the actual letter width, while **monospaced typefaces** have an equal amount of space between all letters. You often use the latter in special environments, like IDE for programming, where you want the letters to line up.


{% picture 1-proportionalvsmonospaced-1efe1205c1bd9e0241b5b2381419b553.jpg %}


### Weights & Styles

Often a single typeface ships with more than 10 different styles in different weights and styles. Weights are often classified as “light”, “thin”, “regular”, “medium”, “bold”, “heavy”, or “black”. Each of these refers to the thickness of the strokes that make up the characters.

{% picture 1-weights-5d0fc7171195e2e9529d0069299ee9c3.jpg %}

There are three general styles you’ll find with many typefaces: italic, oblique, and small caps. Small caps are often used for headings or subheadings, to add variety to your typography if using a single typeface.

Italic and oblique are often confused or used interchangeably, but are two distinct styles. Oblique type is simply a slanted version of the regular characters. You could create this using the “distort” function in Photoshop, although sometimes a separate oblique font is included within a typeface. Italics are slanted like obliques, but are actually a separate set of characters, with their own unique letterforms.

{% picture 1-styles-f3a95937a5eabea30fc1664c5900d87f.jpg %}


Typeface Appearance
-------------------

The mood of a typeface is an important part of how it should be used. Different typefaces have strikingly different moods. Commonly used moods include formal vs. informal, modern vs classic/traditional, and light vs dramatic. Some typefaces have very distinct moods. For example, Times New Roman is pretty much always going to be a traditional font, which is why it’s so commonly used for business correspondence. Verdana, on the other hand, has a more modern mood.

Some typefaces are more transcendent, and can convey almost any mood based on the content and the other typefaces they’re combined with. Helvetica is often considered one such font.

{% picture 1-mood-63af75e6992e372606f31cd1f021dae4.jpg %}


The Anatomy of a Typeface
-------------------------

The different letterforms within a typeface share a few common characteristics. These characteristics can be important in determining whether two (or more) typefaces work well together, or clash. Here are the most basic parts of a typeface.

{% picture 1-heightsandlines-5fd0db4b96968f201132440ce1812ce2.jpg %}

If you'd like to know more about the anatomy of typefaces, "[anatomy of a typeface](http://typedia.com/learn/only/anatomy-of-a-typeface)" is a great place to go. I also recommend you to watch the [Helvetica The Movie](http://www.helveticafilm.com/).


Rule-based typography
---------------------

Before the computer and programming, a typeface was something a designer would sit down and carve into metal. Funny enough, it's kind of the same procedure to do a typeface today, although designers use a mouse instead. With the computer comes the ability to generate forms, and there's a range of different typefaces that a "natively computational".

One of the first fonts to focus on a variable set of related shapes was the Univers typeface by Adrian Frutiger. Made in 1954, Frutigers approach to the design of Univers was drastically different than that of others fonts: Instead of focusing on the relation between the letters of the same weight, he focused on creating a system of inter-related weights that would function well against each other. This raises a series of questions: What should the default weight be in order to preserve room for both lighter and bolder variants? How do you distribute the weights?

{% picture univers-5c508d0357af2333f6d7108d150d9219.jpg %}

**MetaFont** was possibly the world's first parametrized typeface (created in 1977). It was created by Donald Knuth for the typesetting of his life-work [The Art of Computer Programming](http://en.wikipedia.org/wiki/The_Art_of_Computer_Programming). Most fonts are created by designing the outline of the font. When a typeface has to be created in different weights, you cannot just "grow" or "shrink" this outline computationally. A designer has to sit and create new outlines by hand. MetaFont takes a drastically new approach. Instead of being described by its outline, this font is represented by a series of variables inspired by handwriting:

* Pen
* Weight
* Slant
* Superness
* Curlyness

{% picture metafont-0b80a90216f630cbe9ff7f2b96776738.jpg %}

By manipulating these variables you can create very different styles of the MetaFont, as shown in these screenshots.

{% picture metafont_example-b751efa5aa689ed68b515ff8fc8c2142.jpg %}

{% picture metafont_example2-df477d66d1ce810bb16517759d0fe019.jpg %}

{% picture metafont_example3-35bc603b731019697eff0dfba2e02c37.jpg %}

{% picture metafont_example4-323664f042a4fc1b8c00523b4cd598fc.jpg %}

You can read more about metafont in the text "[A Note on Type](http://www.servinglibrary.org/read.html?id=8)" from the magazine [Bulletins of the Serving Library](http://www.servinglibrary.org/). There's also a great talk by [Knuth at Google](http://www.youtube.com/watch?v=xLBvCB2kr4Q) and a link to his original paper on [Mathematical Typography](http://www.math.lsa.umich.edu/~millerpd/docs/501_Winter08/Knuth79.pdf) to be found on the web.

Although the MetaFont is probably unique, this approach inspired a whole new set of typefaces bundled under the name [Type Systems](http://www.typotheque.com/articles/designing_type_systems).

[Greta](http://www.typotheque.com/blog/greta_system) is a universal type system. It was conceived from the start to be a type system, and all aspects of the font are chosen in relation to the bigger picture. However, it is not generated by code. Each letter in each weight is designed by hand.

{% picture greta-a8765019c74504370c694cc4c07077ed.jpg %}

If you overlay the different weights on top of each other, you realize the algorithmic approach to design that was used for Greta. Could it have been designed in code?

{% picture greta_process4-c5035e41457f762b69595b61e3d932a4.jpg %}

A whole different aspect of font design is 3-dimensional typography. Most of these fonts are more artsy in nature, where the font itself is as much an art project in itself as it is a font. There is [a whole book about it](http://www.amazon.com/Dimensional-Typography-Words-Space-Report/dp/1568980892).

[Ortho Type](http://www.ortho-type.it) is a 3D typeface that ships with custom software that allows the user to manipulate the 3D view, width, height, depth, thickness and color of the typeface via UI controls. [You can try it out here](http://www.ortho-type.it/beta033/index.html).

{% picture ortho-a24aca63a1c1768b5ca1884f93740c9a.jpg %}

[ECAL published a book about scripted typography](http://www.jrp-ringier.com/pages/index.php?id_r=4&id_t=&id_p=7&id_b=1604), however it's out of print and impossible to get a hold of.


Code and Typefaces
------------------

I often divide generative typography projects into two distinct categories: **Rule-based** typefaces are typefaces that are built on a simple rule and generated entirely in code, without referencing an existing font. **Outline manipulations** are projects where an existing fonts are loaded and manipulated in code.

I'm going to explore both of these types of typefaces in the following, although I prefer **rule-based** typefaces.


Fonts in Processing
-------------------

Processing ships with built-in font handling. To manipulate text, we need to know how to get the basic measurements of the things we draw. Here's an example of how to find the edges of a word you're drawing on the screen.

One thing to note is that the red circle is at location 0,0. Processing text draw upwards on the y axis. This is called the baseline, and is often used as the basis of a grid system (which we'll look at next week).

{% picture measurements-2c62567e44dc475a937d31bb092dab38.jpg %}
[Example on Github](https://github.com/runemadsen/printing-code/tree/master/typography/font_measurements)


Rule-based fonts in Processing
------------------------------

When working in code, we do not want to plot all outline point manually. It's much slower than doing it in Illustrator, and it's not what code is good for. On the other hand, code is great for dynamic, rule-based drawing. Here's a few examples of how to create simple letters from simple rules.

**Normalization**

Let's say that you want to create a custom uppercase "H" with vertex points. You could just draw the character by plotting the points on the screen:

{% picture font_beginshape-5b42bf54883db4514f46c08282725d56.jpg %}
[Example on Github](https://github.com/runemadsen/printing-code/tree/master/typography/font_beginshape)

However, this is not scalable. What if you want to draw "H" several places in different sizes? Then it's easier to normalize the numbers and scale them up when drawing.

{% picture font_beginshape_normalized-e0f85671315e5e1eddf5e983c8233786.jpg %}
[Example on Github](https://github.com/runemadsen/printing-code/tree/master/typography/font_beginshape_normalized)

However, most of the really interesting computational typography leverages simple rules to compute the letters, instead of relying on the plotting of outline points.

Here's the simplest possible font, made up by a 4x6 matrix:

{% picture pixel_font-c520c5c993abd747931f3aa866b6fbe0.jpg %}
[Example on Github](https://github.com/runemadsen/printing-code/tree/master/typography/pixel_font)

That seems a little silly. Here's a better, but still simple example of the word "meme", that is also scalable.

{% picture meme-3603ad790601944ae21f695035c641f3.png %}
[Example on Github](https://github.com/runemadsen/printing-code/tree/master/typography/meme)

However, making a rule-based font is much of the same process. Let's look at Peter Cho's pie font example again.

{% picture creativecodes86-d5a308655457209c325f6de9200cbaeb.jpg %}

Here's a Processing sketch implementing the same rules. It really doesn't take much work.

{% picture piefont-7ddab1ca0046c48f8a7dab4355ce566f.jpg %}
[Example on Github](https://github.com/runemadsen/printing-code/tree/master/typography/pie_segments_example)


Outline Manipulations in Processing
-----------------------------------

The implementation of fonts in Processing leaves much to be desired. When you go to "Create Font" in Processing, a bitmap image of that font is created (.vlw file). Whenever you need to draw a font on the screen, Processing will look up that bitmap image, grab the characters from it, and draw them on the screen. This has a few disadvantages:

1. Fonts are normally defined by Vector points, but Processing handles them as bitmaps. The bigger the font, the bigger the file size of that bitmap file is. For print designers this is not good, as we're often working with files with really high resolutions, and your program will get really slow when drawing giant text.

2. Fonts will not work in the rendered PDF if the print computer does not have it installed.

To solve these problems we will need to use the external library [Geomerative](http://www.ricardmarxer.com/geomerative/) library for Processing 2.0. The library itself can do a ton of things related to computational geometry. Today we'll look at some of the classes that relate to the use of fonts. You can search through the rest of the classes in [the online documentation](http://www.ricardmarxer.com/geomerative/documentation/index.html).

**RFont** is the main class that you can use for displaying text on the screen. It will read a .ttf font file and draw it on the screen in vectors. This means that when you save your PDF, the font will also be scalable.

Here's a sketch that shows you the basics of drawing a font on the screen.

{% picture geomerative_font-ef3d66447f865fac3fdafac36bc76b54.png %}
[Example on Github](https://github.com/runemadsen/printing-code/tree/master/typography/geomerative_font)

But the RFont class can do much more than that. It's especially good for getting the outline of a font and playing around with it.

There are several ways you can access the outline of a font. The first one is by letting Geomerative generative a static number of x,y values around the outline. The second way is by actually accessing the vertices (beziers, etc) directly.

**Static Outlines**

Here's a sketch that shows you how to do the first: Getting a reduced, static number of points from a font. The first sketch here shows you how to do it with a single letter. Notice how many loops we need, as a single RPolygon will always have an array of RContours that themselves have an array of RPoints.

{% picture rfont_reduced-e37689375a3c9a96e1ab4873c65dac66.png %}
[Example on Github](https://github.com/runemadsen/printing-code/tree/master/typography/rfont_reduced)

If you want to do this with more than one character, you will need an extra loop, as each polygon comes in an array of the RGroup.

{% picture rfont_reduced_word-6c034eea12a79d612ba98a8d8ee0bb10.png %}
[Example on Github](https://github.com/runemadsen/printing-code/tree/master/typography/rfont_reduced_word)

Now that we can access the reduced points of the outline, let's play around with them!
  
{% picture font_to_points_dots-0e0e03039c4fad5362a4c58f02c7efb8.jpg %}
[Example on Github](https://github.com/runemadsen/printing-code/tree/master/typography/font_to_points_dots)
  
Here's that same code, but using beginShape to play around with the contours.

{% picture font_to_points_generative-4fcbbeb35087508a10735f441c365df1.jpg %}
[Example on Github](https://github.com/runemadsen/printing-code/tree/master/typography/font_to_points_generative)

**Non-Reduced Outlines**

If you want to access the actual vertices of the shapes, you should look into the RShape and RCommand classes. 


Project Examples
----------------

So why do I say that I don't believe in computational typography? Because typefaces have a distinct function: readability. This can often only be achieved by fine-tuning every single point by hand. This is not something that programming is good for.

Still I see a ton of these projects. Destroying beautiful fonts by moving their outlines:

{% picture generativeges141-4415f6d1b5003962251eba5c8bab284d.jpg %}

{% picture generativeges143-732c50f16a2f06ffc66a1c9aeb1bafaa.jpg %}

Who cares about making a font uglier?

These next examples go a little beyond that. I still think half of them are unsuccessful, but at least there's some kind of compositional beauty. sThis is a showcase of final projects from a class on generative typography. [Read more on the class website](http://generative-typografie.de/).

{% picture generativeges73-62173200cebeb3bb49f193c5655cbda6.jpg %}

Here's a few examples of projects that I really like, because it's more a case of testing a specific set of rules, than it is to move outline points around randomly:

John Maeda describes this project by Peter Cho as "unique for marrying extremely simple numerical form with true elegance in craft". Each letter is generated with only 2 arcs, and the entire typeface is derived from twenty-six groups of only ten numbers. The project is from 1997.

{% picture creativecodes86-d5a308655457209c325f6de9200cbaeb.jpg %}

Another project from the Aesthetics and Computation Group at MIT. It's called "Robotic Arm as Typeface", and that's exactly what it is. A typeface made up of a single, moving robotic arm. The project is from 2001.

{% picture creativecodes93-7e2c1a6af3750ea8a2798ee7ccdf1e3e.jpg %}


Here's some examples of the work of Jonathan Puckey. I really like them because it's not so much about manipulating outlines of a font. He's building new designs from a set of simple rules.

Here's his project "Tile Tool" that draws patterns on top of black and white base images. He also made a project called "Typographic Rhytm" where he picks a font weight for each letter depending on the time it took you to type the character.

{% picture generativeges113-a0d6e4b539054e98be1215abeb4cba55.jpg %}

{% picture generativeges114-147301071cde741353a7e301ce31b89c.jpg %}

{% picture generativeges115-af8e34bd854e0a4c46c0391bb86eadb9.jpg %}

This next project is really great. It's a dynamic typeface made for the small film studio "Lava Films". It's based on the concept of natural disasters: Things moving to non-anticipated places. So is the font.

<iframe src="http://player.vimeo.com/video/23500126?title=0&amp;byline=0&amp;portrait=0" width="600" height="338" frameborder="0"> </iframe>

{% picture lava-e1d2d5423117d9e9eb8405bb85ee11d0.jpg %}

{% picture lava2-3eaae44e326f33aa894b9cb7cb4962ce.jpg %}

{% picture lava3-dda89c3bff5d84b338b08d009f2c32d6.jpg %}

{% picture lava4-dd02dedec2c9fbe0b89805dae5e59b2b.jpg %}

{% picture lava5-c3425a9d3f53ac5b2d3d57b686428f57.jpg %}

.. but it's not created with programming.

Here's a few more projects that go beyond the paper. Here's it's an automatic brush.

{% picture atouchofcodes223-b6a8d451e90abebf3bbddb3cae84fbdc.jpg %}

Here's a project combining evolution and typography. "Growing Data" from 2008.

{% picture generativeges77-542e57036197508be5a1629488428088.jpg %}

Of course there's Karsten Schmidts evolutionary typeface, that he made for "Print" magazine.

{% picture generativeges135-e5821ce6e4f256436412f2486be7f84e.jpg %}